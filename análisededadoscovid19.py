# -*- coding: utf-8 -*-
"""análiseDeDadosCovid19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-4Fi5Ct1qQpWFCP9m2aGw3VGTaomFQ3f

# Projeto COVID-19
## Digital Innovation One
"""

#importar as bibliotecas a serem usadas
import pandas as pd
import numpy as np
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go

#importar os dados a serem usados do próprio github
url = 'https://github.com/neylsoncrepalde/projeto_eda_covid/blob/master/covid_19_data.csv?raw=true'

#criando o data frame(df)
df = pd.read_csv(url, parse_dates=['ObservationDate', 'Last Update'])
#imprimindo os 5 primeiros
df.head()

#imprimir quantiade de linhas e coluna do df
df.shape

#conferir os tipos de dados
df.dtypes

"""Nomes de colunas não devem ter letras maiúsculas e nem caracteres especiais. Vamos definir uma função para fazer a limpeza dos nomes dessas colunas."""

import re
#se tiver / ou espaço em bc, vai substituir por nada e passar as letras p minúsculo
def corrige_colunas(col_name):
  return re.sub(r"/| ", "", col_name).lower()

corrige_colunas("ABC/ eddd")  #testando

#corrigir todas as colunas
df.columns = [corrige_colunas(col) for col in df.columns]

df

"""# Brasil
## Vamos trabalhar com dados apenas do Brasil
"""

df.loc[df.countryregion == 'Brazil']

#pegando os dados somente do br e com pelo menos um caso confirmado
brasil = df.loc[(df.countryregion == 'Brazil') &(df.confirmed > 0)]

"""# Casos Confirmados"""

#gráfico de linha dos casos confirmados
px.line(brasil, 'observationdate', 'confirmed', title='Casos confirmados no BR')

"""#Novos casos por dia"""

#criando uma nova coluna, iloc busca pelo id
brasil['novoscasos'] = list(map(lambda x: 0 if (x==0) else brasil['confirmed'].iloc[x] - brasil['confirmed'].iloc[x-1], np.arange(brasil.shape[0])))

#gráfico de linha dos novos casos
px.line(brasil, 'observationdate', 'novoscasos', title='Novos casos por dia no BR')

"""#Mortes

"""

fig = go.Figure()

fig.add_trace(go.Scatter(x=brasil.observationdate, y=brasil.deaths, name='Mortes', mode='lines+markers', line={'color':'red'}))
fig.update_layout(title='Mortes por COVID19 no BR')
fig.show()

"""#Taxa de Crescimento

taxa_crescimento = (presente/passado)**(1/n) - 1
"""

def taxa_crescimento(data, variable, data_inicio=None, data_fim=None):
    #Se a data inicio for none, define c a primeira data disponivel
    if data_inicio == None:
      data_inicio = data.observationdate.loc[data[variable] > 0].min()
    else:
      data_inicio = pd.to_datetime(data_inicio)

    #Se a data final for none, define c a ultima data disponivel
    if data_fim == None:
      data_fim = data.observationdate.iloc[-1] #o -1 significa que pega o ultimo caso
    else:
      data_fim = pd.to_datetime(data_fim)

    #definindo os valores de presente e passado
    presente = data.loc[data.observationdate == data_fim, variable].values[0]
    passado = data.loc[data.observationdate == data_inicio, variable].values[0]

    #defindo n, o numero de pontos no tempo que vamos avaliar
    n = (data_fim - data_inicio).days

    #Calcular a taxa
    taxa = (presente/passado)**(1/n) - 1

    #como quero em porcentagem, multiplico por 100
    return taxa*100

#taxa de crescimento médio de casos confirmados no brasil em todo o período
taxa_crescimento(brasil, 'confirmed')

#vamos calcular a taxa de crescimento diário
def taxa_crescimento_diario(data, variable, data_inicio=None):
    #Se a data inicio for none, define c a primeira data disponivel
    if data_inicio == None:
      data_inicio = data.observationdate.loc[data[variable] > 0].min()
    else:
      data_inicio = pd.to_datetime(data_inicio)


    #a data fim é necessariamente a ultima disponivel
    data_fim = data.observationdate.max()

    #defindo n, o numero de pontos no tempo que vamos avaliar
    n = (data_fim - data_inicio).days

    #calculando a taxa
    taxas = list(map(
        lambda x: (data[variable].iloc[x] - data[variable].iloc[x-1]) / data[variable].iloc[x-1], range(1, n+1)
    ))
    return np.array(taxas) * 100

tx_dia = taxa_crescimento_diario(brasil, 'confirmed')

tx_dia

primeiro_dia = brasil.observationdate.loc[brasil.confirmed > 0].min()

px.line(x=pd.date_range(primeiro_dia, brasil.observationdate.max())[1:],
        y=tx_dia, title='Taxa de crescimento de casos confirmados no Brasil')

"""#Predições"""

from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt

confirmados = brasil.confirmed
confirmados.index = brasil.observationdate
confirmados

res = seasonal_decompose(confirmados)

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10,8))

#mostrar os observados
ax1.plot(res.observed)
#mostrar a tendencia
ax2.plot(res.trend)
#mostrar a sazonalidade
ax3.plot(res.seasonal)
#mostrar o ruido
ax4.plot(confirmados.index, res.resid)
ax4.axhline(0, linestyle='dashed', c='black')
plt.show()

"""#ARIMA"""

!pip install pmdarima

from pmdarima.arima import auto_arima
modelo = auto_arima(confirmados)

fig= go.Figure(go.Scatter(
    x=confirmados.index, y=confirmados, name='Observados'
))

fig.add_trace(go.Scatter(
    x=confirmados.index, y=modelo.predict_in_sample(), name='Preditos'
))

fig.add_trace(go.Scatter(
    x=pd.date_range('2020-05-20', '2020-06-20'), y=modelo.predict(31), name='Forecast'
))

fig.update_layout(title='Previsão de casos confirmados no BR para os próximos 30 dias')
fig.show()

"""#Modelo de crescimento"""

!conda install -c conda-forge fbprophet -y

!pip install prophet

from prophet import Prophet

#Preprocessamentos
train = confirmados.reset_index()[:-5]
test = confirmados.reset_index()[-5:]

#Renomeando colunas
train.rename(columns={'observationdate':'ds', 'confirmed':'y'}, inplace=True)
test.rename(columns={'observationdate':'ds', 'confirmed':'y'}, inplace=True)

#Definir o modelo de crescimento
profeta = Prophet(growth='logistic', changepoints=['2020-03-21', '2020-03-30', '2020-04-25', '2020-05-03', '2020-05-10'])

pop = 211463256
train['cap'] = pop

#Treinar o modelo
profeta.fit(train)

#Construir previsões para o futuro
future_dates = profeta.make_future_dataframe(periods=200)
future_dates['cap'] = pop
forecast = profeta.predict(future_dates)

fig= go.Figure()

fig.add_trace(go.Scatter(x=forecast.ds, y=forecast.yhat, name='Predição'))
fig.add_trace(go.Scatter(x=train.ds, y=train.y, name='Observados - Treino'))
fig.update_layout(title='Predição de casos confirmados no BR')
fig.show()